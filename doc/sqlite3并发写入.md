# sqlite3并发写入

在数据库操作未加锁之前, 多协程从channel队列中取任务, 再删除数据库中该任务的持久化记录, 会出现某些任务没有被删掉的情况. 一直不明白原因, 因为在删除持久化记录后再查询, 这个记录明明已经删掉了. 而且每次运行, 未删除的记录是会变动的.

之后尝试为每张表的写操作都加上锁, 为此还拆分了`page_task.go`和`asset_task.go`, 但这样在运行的时候出现了`database is locked`错误...

后来再查询资料, 发现sqlite3不支持表级锁, 只支持库级锁. 

什么意思呢? 

我们通过`Open`创建一个数据库连接(实际上是一个连接池), 只能有单个协程能使用其对数据库进行操作, 就算不同协程操作的表不同也一样. 

这不同于我们常规的多线程数据库操作: 开一个连接池, 实际上与数据库建立了多条连接, 不同协程获取到的数据库连接都是池中的可用连接(gorm是支持多协程, 是并发安全的), 不需要额外加锁.

不过这样一个小程序运行时再开postgres, mysql这种数据库又有点太重了, 所以目前还是先这样吧, 起码安全.

...有一个用golang实现的基于sqlite的分布式数据库[rqlite](https://github.com/rqlite/rqlite), 不知道是不是可以用于轻量的本地存储, 以后试试.
